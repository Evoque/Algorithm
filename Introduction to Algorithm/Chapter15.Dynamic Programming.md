# Dynamic Programming - 动态规划



## 15.1 钢条切割问题

**问题描述如下:**

	给定一段长度为n英寸的钢条和一个价格表$${p}_i$$($$_i$$=1, 2, ..., n), 求切割钢条方案，使得销售收益$$r_n$$最大。 注意，如果长度为n英寸的钢条的价格$p_n$足够大，最优解可能就是完全不需要切割。

如下$p_i$样例： 

| 长度$_i$    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
| ----------- | :--- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 价格$$p_i$$ | 1    | 5    | 8    | 9    | 10   | 17   | 17   | 20   | 24   | 30   |

> 题目中有个隐含信息，即给定的长度`n`, 对应的价目表的长度也为`n`,  即存在$p_n$。

通过观察分析，我们把最优解转化为更一般的形式，即对于$r_n(n{\ge}1)$，我们用一个公式描述:
$$
r_n=max(p_n, r_1+r_{n-1}, r_2+r_{n-2}, ..., r_{n-1}+r_1)
$$

> 这个公式的核心是: 通过**更短**的钢条的最优切割收益来描述它；很明显，通过二分递归来转化为子问题求解。
>
> 我首次想到的解决办法是我惯性思维想出的，但是事实证明增加了复杂度：
>
> 1. 长度为`n`的钢条，有$2^{n-1}$种不同的切割方案， 所以我首先想到的是先确定出这$2^{n-1}$种切割方案；
>
> 2. 然后分别计算每个方案对应的最优解，得到`max` 即可。 
>
>    > 翻来覆去的想，这样的解法似乎没什么问题， 但是如何得出不同的切割方案时犯了难。而且，求出$2^{n-1}$种方案之后，要进行$2^{n-1}$次求值计算，指数级的时间复杂度显示是无法接受的。
>    >
>    > 不过，怎么计算出$2^{n-1}$种解决方案，并把它们去重也是一个值得思考和尝试的问题， 具体见下面的**解法部分**。
>    >
>    > 刚顶着雾霾骑车去公司拿东西，路上突然想明白，其实寻找$2{n-1}$种切割方案也是一个动态规划问(感谢北京的雾霾....:smile:)。

- 重点：如果能用一个合适的公式把算法描述出来，那么这个算法按照这种思路已经被解决一半了。 这种方式得到的解决方案往往也是比较靠谱的。

得到如下代码:

```javascript
/** 数组index对应钢条长度n, value对应价格 */
const p = [,1,5,8,9,10,17,17,20,24,30];
function top_down_optimal(n){
    let val = p[n];
    for (let i = 1; i < n; i++){
        const ri = top_down_optimal(i);
        const rn_i = top_down_optimal(n - i);
        if(ri + rn_i > val) {
            val = ri + rn_i;
        }
    }
    return val;
}
```

经过测试， 上面的代码执行了正确的结果， 但是仅凭这些代码还是看不出具体执行了哪些操作， 所以我们通过图的形式来遍历算法二分递归的所有情况。 

```markdown
				{4:9}
	{1+3:9}     {2+2:10}     {3+1}
 [1:1] [3:8]
 	{1+2:6} {2+1}
  [1:1] [2:5]
  	 [1:1]
```

上面是个简易的遍历图示，如 当n为4时，4本身对应的$p_4$为9，遍历拆分的第一个子项为:1+3。然后对1和3分别递归遍历，1得到结果1，3在得到自身的结果$p_3$之后对自身再次进行递归，得到:1+2, 2+1, 循环遍历此过程，一次的最深计算如下面公式:

```
1⃣️1+3 => 1, 3: 得到1的值1，3的值8；对3进行递归
	2⃣️1+2 => 1, 2: 得到1的值1，2的值5；对2进行递归
		3⃣️1+1 => 1:1, 1:1
	2+1 => 2, 1: 得到1的值1，2的值5；对2进行递归 
```

如上，1⃣️ — 2⃣️ — 3⃣️ 是一次最深的遍历过程，我们从后往前计算结果， 3⃣️对应的最大值为2，而2本身对应的值为5，所以2⃣️的结果为1(1)+2(5) = 3(6); 而3本身对应的结果为8, 所以1⃣️1(1)+3(8)=4(9)，知道1+3的最优解等于4本身的最优解，所以第一次最深的遍历得到结果9。

同理，递归遍历(2+2), (3+1)....

到这里，在leetcode上遇到的[53.Maximum Subarray](https://leetcode.com/problems/maximum-subarray/description/)也知道怎么去理解了，当然，leetcode上的题目是经过变种的，不是上面那么直白的形式。 

OK，基本解法明白之后咱分析一下效率， 然后合计合计怎么优化：

**Drawbacks:**

- 时间复杂度无法忍受：$2^{n-1}$(节点的分割方式是i,n-i; 二叉树的最大节点数)
- 大量的重复计算: 如(1,3), (3,1), (2,2)等， 



**除了上述求解方法外，还存在一种相似的但更为简单的递归求解方法：**

我们将钢条从左边割下长度为i的一段，只对右边剩下的长度为n-i的一段继续进行切割(递归求解),对左边的一段则不再进行切割。即问题分解的方式为：将长度为n的钢条分解为左边开始一段，以及剩余部分继续分解的结果。这样，不做任何切割方案就可以描述为：第一段的长度为n，收益为$p_n$，剩余部分长度为0，对应的收益为$r_n$=0。于是我们可以得到下面公式的简化版本:
$$
r_n = \max_{1{\le}i{\le}n}(p_i + r_{n-i})
$$
在此公式中，原问题的最优解只包含一个相关子问题(右端剩余部分)的解，而不是两个。

> 为什么可以对左边的不再求解?
>
> 是否可以通过这种形式描述所有的切割方案？  Not Understand Evoque



	





## 思考

1. 数字n，有$$2^{n-1}$$种分割方式； 如`2`可拆分成`1+1, 2`两种，`3`可拆分成`1+1+1, 1+2, 2+1, 2`四种，及$$2^{n-1}$$; 那么为什么是$$2^{n-1}$$呢？

   > 自己想的解释为：
   >
   > - 当`n`为`2`时，有`1+1, 2`两种解决方案; 
   > - 那么当`n`为`3`时，`3=2+1`，转化一下， 也就是在`2`的拆分方案的子项各加一，得到两种拆分方案；
   > - 如`2`中的`1+1` => 变成`3`中的`(1+1)+1, 1+(1+1)`，即`2+1, 1+2`两种拆分方案；
   > - 所以`n`的拆分方案是在`n-1`的拆分方案的基础上`乘以2`，再去除自身不用拆分的情况，即得到结果$$2^{n-1}$$

   > 又经过了一番演算，发现上面的推导方式是不正确的。  * Evoque, 未解决